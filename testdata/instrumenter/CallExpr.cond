package instrumenter

// https://go.dev/ref/spec#Calls

// TODO: Add systematic tests.

// callExpr covers the instrumentation of [ast.CallExpr], which has the
// expression fields Fun and Args.
//
// Call expressions are not instrumented themselves.
func callExpr(a bool, b string) bool {
	// Those arguments to function calls that can be clearly identified
	// as boolean expressions are wrapped. Direct boolean arguments are
	// not wrapped since, as of January 2023, gobco does not use type
	// resolution.

	if GobcoCover(0, len(b) > 0) == true {
		return callExpr(GobcoCover(1, len(b)%2 == 0) == true, b[1:])
	}

	// A CallExpr without identifier is also covered.
	(func(a bool) {})(GobcoCover(2, 1 != 2) == true)

	// The function expression can contain conditions as well.
	m := map[bool]func(){}
	m[GobcoCover(3, 3 != 0) == true]()

	// Type conversions end up as CallExpr as well.
	type myBool bool
	_ = myBool(GobcoCover(4, 3 > 0) == true)

	// There may be custom types based on bool,
	// and these types cannot be directly assigned to bool.
	// https://github.com/rillig/gobco/issues/35
	toMyBool := func(i int) myBool { return GobcoCover(5, i%2 == 0) == true }
	if GobcoCover(6, toMyBool(4) == true) == true {
	}

	fromMyBool := func(m myBool) bool { return bool(m) }
	if GobcoCover(7, fromMyBool(GobcoCover(8, toMyBool(3) == true) == true && GobcoCover(9, toMyBool(6) == true) == true) == true) == true {
	}

	return false
}

// :17:5: "len(b) > 0"
// :18:19: "len(b)%2 == 0"
// :22:20: "1 != 2"
// :26:4: "3 != 0"
// :30:13: "3 > 0"
// :35:42: "i%2 == 0"
// :36:5: "toMyBool(4)"
// :40:5: "fromMyBool(toMyBool(3) && toMyBool(6))"
// :40:16: "toMyBool(3)"
// :40:31: "toMyBool(6)"
